-module(util_lists).
-author("Ryan.Flynn@teamaol.com").
-export([proplist_part/2, tests/0,test_proplist_part/0]).

% partition a proplist into 2 lists: one having keys in Keys, the other not
% sort input and then filter into Yes or No buckets
proplist_part(P, Keys) ->
    proplist_part(lists:keysort(1, P), lists:sort(Keys), [], []).
proplist_part([], _, Y, N) ->
    {lists:reverse(Y), lists:reverse(N)};
proplist_part([P|PT], [], Y, N) ->
    proplist_part(PT, [], Y, [P|N]);
proplist_part([{PK,_}=P|PT], [K|KT], Y, N) when K == PK ->
    proplist_part(PT, KT, [P|Y], N);
proplist_part([{PK,_}=P|PT], [K|KT], Y, N) when K < PK ->
    proplist_part([P|PT], KT, Y, N);
proplist_part([{PK,_}=P|PT], [K|KT], Y, N) when K > PK ->
    proplist_part(PT, [K|KT], Y, [P|N]).

% TODO: extract generic unit tests to their own module
unittest(_Fun, [], Res) -> lists:reverse(Res);
unittest(Fun, [{Args,Expected}|Tail], Res) ->
    Result = apply(Fun, Args),
    Res2 = if
        Result =/= Expected -> "FAIL";
        true -> "ok"
    end,
    unittest(Fun, Tail, [{Args,Expected,Result,Res2}|Res]).

test_proplist_part() ->
    InOut = [
        {[[],[]], {[],[]}}, % base case
        {[[],[0]], {[],[]}},
        {[[{"k","v"}],[]], {[],[{"k","v"}]}},
        {[[{"k","v"}],["k"]], {[{"k","v"}],[]}},
        {[[{"k","v"}],["k2"]], {[],[{"k","v"}]}},
        {[[{"k","v"}],["k","k2"]], {[{"k","v"}],[]}},
        {[[{"k","v"}],["k2","k"]], {[{"k","v"}],[]}},
        {
            [[{"x",1},{"y",2},{"z",3}],["x"]],
            {[{"x",1}],[{"y",2},{"z",3}]}
        },
        {
            [[{"x",1},{"y",2},{"z",3}],["y"]],
            {[{"y",2}],[{"x",1},{"z",3}]}
        },
        {
            [[{"x",1},{"y",2},{"z",3}],["z"]],
            {[{"z",3}],[{"x",1},{"y",2}]}
        },
        {
            [[{"x",1},{"y",2},{"z",3}],["x","y"]],
            {[{"x",1},{"y",2}],[{"z",3}]}
        },
        {
            [[{"x",1},{"y",2},{"z",3}],["x","z"]],
            {[{"x",1},{"z",3}],[{"y",2}]}
        },
        {
            [[{"x",1},{"y",2},{"z",3}],["y","z"]],
            {[{"y",2},{"z",3}],[{"x",1}]}
        },
        {
            [[{"A",1},{"a",2},{"b",3}],["b","A"]],
            {[{"A",1},{"b",3}],[{"a",2}]}
        },
        {
            % looking for keys that don't exist
            [[{"A",1},{"a",2},{"b",3}],["b","A","K","X","Y","Z"]],
            {[{"A",1},{"b",3}],[{"a",2}]}
        }
    ],
    unittest(fun proplist_part/2, InOut, []).

testresults_bool(TestResults) ->
    % reduce all our wonderful in-depth data to pass/fail
    % needed because unit tests output is limited to pass/fail, bummer
    Pred = fun({_Args,_Exp,_Res,OK}) -> OK =/= "ok" end,
    case lists:any(Pred, TestResults) of
        true -> "FAIL";
        _ -> ok
    end.

tests() ->
    {tests, [
        {proplist_part,     testresults_bool(test_proplist_part()) }
    ]}.


