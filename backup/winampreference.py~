#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ex: set ts=4 et:

"""
    WinampReference
        This reference intends to be an exceptionally clear example
        of what we expect the various winamp clients to do to
        communicate with the erlang server.

        The goal is not to be perscriptive in the details, but to 
        cover all the points that must be in agreement between all
        the devices that talk to the server.

        It is important that we hang the events on methods that 
        client implementors will instantly grok.

    Current Thinking
        Initially, we thought that a shared data format might be 
        useful (SQLite).  I now suspect that we have to be totally
        agnostic of the storage format on the device.  As we talked
        about the implementation, we realized it is actually all 
        about minimal updates to point data per song, not to the 
        database as a whole.

        I also think we should combine updates with conflict 
        resolution into a single step.  Talked about more in 
        Updates and conflicts.

        Over time this will specific details like how to poll or 
        leave open connections to the server, but for .1 we just
        have to define behavoirs that are purely local.

    Updates and conflicts
        Updates will happen right away when connect to the cloud, 
        or will be added to a backlog if not connected.  Updates 
        will happen concurrently (# to be tweaked later).  Conflicts
        will come down A/B style to be handled right away.  This 
        should allow them to work well even on small screens. 

        So you can consider the updates to be sequentially pushed 
        up when the client connects, failures will ignore time and
        simply ask the user what they want, A or B.
"""
class WinampReference:

    def play_song(self, song):
        # for frame in song.mediaframes 
            # should we increment playcount yet?
                # increment_playcount
                # update_or_backlog
        pass

    def import_song(self, path):
        # generate or confirm hash (song can be 'imported' on top of existing songs)
        # if data change
            # update_or_backlog
        pass

    def update_meta(self):
        # update local file meta (or just cloud meta, if this is via the client they expect it to work locally)
        # update_or_backlog
        pass

    def update_or_backlog(self):
        # up the server if we are connected
        # else add to the backlog
