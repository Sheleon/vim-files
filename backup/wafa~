ReplicantLinux
    ReplicantCore
        Playback
        Metadata
        Library
        Transcoding
        Playlist
ReplicantWin
    ReplicantCore
ReplicantWAFA
    ReplicantCore
        Playback
        Metadata
        Library
ReplicantMac
    ReplicantCore

Timeline:
    Linux:
        Media ID
    Mac:
    WAFA:
    Desktop:

On Wed, Jan 4, 2012 at 7:07 PM, Allison, Ben <ben.allison@teamaol.com> wrote:
>  - custom DB engine that's a nightmare to maintain, although does give a moderate performance benefit
* squint eyes* I will concede this point, I guess, sorta.  Need to
come up with realistic tests.

> * features that must be maintained, but are easy to forget about
>  - Unicode searching and collation (requires minor modifications to out-of-the-box SQLite, which supports unicode but not necessarily unicode-aware searching and collation)
The search portion is easy via a stored procedure, the collation might
need a loadable extension depending on how "wrong" the SQLite default
language based collation is.
http://www.sqlite.org/c3ref/create_collation.html

>  - 'smart' searching such as removing leading 'The' but maintaining it for display purposes
This is easy enough via stored procedures in SQLite terms.

>  - collation that respects the user's locale and language.  Many languages have different rules about where letters like Ã¼ are sorted, see: http://blogs.msdn.com/b/michkap/archive/2004/12/31/344739.aspx
SQLite supports locale based collation, just not sure if it is good enough.

> * features that we've considered adding to Winamp 5 but couldn't add due to technical limitations
>  - dealing with different filesystem rules for filename case sensitivity.  e.g. FAT32 = insensitive, ext2 = sensitive, NTFS = insensitive by default but can be changed to sensitive.  also, media might be spread out across multiple storage device with differing rules!
Ugh, no idea how to deal with this other than searching.  I suspect we
could have a path of checking the meta-info on the filesystem (quickly
searched) then the meta-info in the header (slower) then generate a
full file-id if it doesn't exist.  It is an ugly problem.

>  - per-storage-device databases.  would allow, e.g., portable USB hard drives and phone SD cards to 'detach' and have the files magically disappear from the database (or show as offline), as well as allow instant database import when attaching to another system
We can simply support multiple sqlite databases to this.

>  - persistent unique IDs
Would some of the media ID work be portable here... how does it handle
changing metadata?  Is this a separate ID from "song ID"

>  - multiple values for a single field, e.g. multiple contributing artists, free-form user-defined 'tags', multiple genres
We could create a custom type via loadable extension... or we could
simply standardize our field data as JSON.  Using JSON field data
seems to be very common response to storing complex data in single
fields.  Tends to be good for fallbacks, opaque to most search
queries, and has exceptional fast / well tuned libraries for loading.

>  - ability for a plugin/component to request addition fields for its use (e.g. storing per-song EQ settings, storing external song IDs e.g. for music store integration)
Do plugins have IDs?  Can we get them one, we could create a single
field per plugin and allow it to store infinitely complex JSON data.

>  - tracking the source of the metadata.  for example, metadata might have imported from another application for "cold start" purposes, but needs to be re-validated against the files' metadata later
I am not sure I entirely understand this one.  Hopefully you can
explain it a bit more.

>  - tracking of non-file media assets, such as HTTP links, SHOUTcast stations.  Not 100% sure if we want this, but might be useful (could be a separate DB with a separate schema, perhaps)
I think it is just a playlist, stored with everything else.  Again, if
we decide to store JSON, it lets us open us a lot of new stuff -- but
it means we are now support two layers of schema.

> * features that would support device syncing and cloud
>  - media fingerprint ID (separate from song ID and possibly duplicated), most likely based on a hash of raw 'media-only' data (no metadata, container, framing, index, header, or other file format data)
Yep, I need the media ID for cloud regardless, it is a required feature.

>  - journaling of changes, to facilitate synchronization.  especially for play counts (e.g. playcount on PC goes from 5 to 10.  playcount on Android goes from 5 to 7.  new playcount should be 12 but that can't be captured by comparing two databases that have '10' and '7' as their values)
From the cloud perspective, since only 1 thing can happen at a time in
relation to users, it would be a +5 request, response "10" to all
connected, then Android would flush before accept, so it would send +2
then return "12 to all connected, so both winamp, android, and cloud
would be at 12.  In terms of device to device, no idea.

>  - some sort of song ID merging when syncing two devices whose databases were created independently but have overlapping content
Rough feature, but would be very cool -- still not sure I understand
how song ID works... I do understand media ID.

>  - well defined rules for propagating changes between devices, both user-made metadata changes as well as file removal and deletion.  user might have wanted the song off their device for space reasons, or might have wanted to permanently remove from library.
This is really important, and for people who don't use the cloud it
will be a bitch.  Cloud simplifies by allowing sort of serialization
on check-in.

>  - ability to link transcoded files.  e.g. when transferring to a device, FLAC (~1000kbps) is usually transcoded to AAC (~128kbps) to save space, but playcount between the two files should still update together
Yep.

>  - tracking of files that are present on other devices but not on the device hosting the database
Yep.

> * Playlists
>  - remember that playlists can contain entries that might not necessarily be in the database
If we want to store shortcuts and stuff this is doubly important...
again, if we buy into the idea of JSON / self-supporting types.

>  - can also contain URIs
Sure!

>  - should store song ID (as well as maybe the media fingerprint ID) in addition to URI/filename to make syncing and remote content easier to manage
Yes please.

>  - like the media library database, we might need a system for merging two independently created playlists that might contain the same data
Do you think we could get it to where mergings databases and playlists
are basically equal?

> * Album art
>  - should we store album art in the database, or just thumbnails?
I think thumbnails only.

>  - if we store thumbnails, how do we manage storing the various sizes that might be needed by different parts of the UI (and we don't necessarily know the dimensions a priori)
The standard answer would be store the largest reasonable thumbnail
size... I assume this is not possible for some reason?
