#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ex: set ts=4 et:

import json
import hashlib
import datetime
import random
import os

class LocalMedia:
    """
    Represents an on-disk media file
    Contains only the metadata (and data) that a media file contains
    Serializes to disk as json -- an easy mock for testing. We know Winamp already knows how to read metadata.
    All metadata is changeable, as is 'songdata' to replicate song editing by an external party
    """

    @staticmethod
    def fromdisk(path):
        lm = LocalMedia(path)
        # try to load from disk, otherwise use default
        try:
            f = open(path, 'r')
            data = json.loads(f.read())
            lm.data = data
            f.close()
        except:
            # error with file, stick with defaults
            lm.save() # ensure an on-disk file always exists
        return lm

    @staticmethod
    def new(path):
        # overwrite file if it exists
        try:
            os.remove(path)
        except:
            pass
        return LocalMedia.fromdisk(path)

    @staticmethod
    def fromdbrow(row):
        lm = LocalMedia()
        # replace defaults with db data
        keys = lm.data.keys()
        r = dict(row)
        d = {}
        for k in keys:
            if k in r:
                d[k] = r[k]
        # NOTE: this intentional destroys 'songdata' since we can't
        # rely on having songdata from every localmedia in the db
        lm.data = d
        return lm

    def __init__(self, path=None):
        self.fromdisk = path is not None
        self.path = path

        # default data
        self.data = {
            # mock data we can change and hash to simulate
            # external song-edits. not mapped to database,
            # though
            'songdata'  : 'ABC',

            # TODO: custom 'mediahash' metadata gets stored
            # in here by us once we've seen this file

            # the rest are straight mappings to the database
            'bitrate'   : '',
            'length'    : -1,
            'title'     : '',
            'artist'    : '',
            'album'     : '',
            'year'      : -1,
            'genre'     : '',
            'trackno'   : -1,
            'tracks'    : -1,
            'disc'      : '',
            'discs'     : -1,
            'composer'  : '',
            'producer'  : '',
            'publisher' : '',
            'comment'   : '',
        }

    def __repr__(self):
        return 'LocalMedia <%s - %s - %s> data=<%s>' % (
                self.data['title'], self.data['artist'],
                self.data['album'], self.data['songdata'] if 'songdata' in self.data else '?')

    def edit_songdata(self):
        self.data['songdata'] += '-edit'

    def save(self):
        if self.path:
            # serialize to file
            f = open(self.path, 'w')
            f.write(json.dumps(self.data))
            f.close()
            return True
        else:
            # if we're metadata-only then there's nothing to save
            return False

    def rename(self, newpath):
        os.rename(self.path, newpath)

    def delete(self):
        os.remove(self.path)

    def __getitem__(self, key):
        return self.data[key]

    def __setitem__(self, key, val):
        self.data[key] = val

    def __eq__(self, other):
        return self.path == other.path and \
               self.data == other.data

if __name__ == '__main__':

    import errno

    # create test dir
    try:
        os.makedirs('test/media')
    except OSError, e:
        if e.errno != errno.EEXIST:
            raise e

    song = LocalMedia.new('test/media/stayin-alive.mp3')
    song['artist'] = 'Bee Gees'
    song['title'] = "Stayin' Alive"
    song['album'] = 'Saturday Night Fever'
    print song
    song.save()
    song.edit_songdata()
    print song

