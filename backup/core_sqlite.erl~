-module(core_sqlite).
-export([sql_script/2, tests/0, create_or_open_db/1, close_db/1, 
         format/2, get_rev/1, safe_initialize_sql/0, sql_exec/2, 
        get_last_inserted_rowid/1, get_changed/1, tests/0]).

% {{{ Defines Explained
%  DB_OP_MAX_MSEC
%    after this many msecs we declare a database timeout;
%    we don't want to retry forever
%
%  DB_OP_RETRY_MSEC
%    if an async op is busy, how long until we check it again?
%    must be <= DB_OP_MAX_MSEC
% 
%  SQLITE_BUSY
%    Ref: http://www.sqlite.org/c3ref/c_abort.html
%    FIXME: is this available in sqlite3: anywhere?
% }}}
-define(DB_OP_MAX_MSEC, 1000).
-define(DB_OP_RETRY_MSEC, 100).
-define(SQLITE_BUSY, 5).

create_or_open_db(Username) ->
    Handle = util_babel:to_atom(Username),
    %% TODO: Fix stupid SQLite driver so it doesn't use 
    %% atoms (cap of 1048576 by default)
    DbFile = "/tmp/"++util_babel:to_list(Username),
    Handle2 = case sqlite3:open(Handle, [{file, DbFile}]) of
        {ok, _Pid} -> safe_initialize(Handle), Handle;
        {error,{already_started,_Pid}} -> Handle
    end,
    {ok, Handle2}.

close_db(DBHandle) when is_atom(DBHandle) ->
    sqlite3:close(DBHandle).

safe_initialize_sql() ->
    {ok, Sql} = file:read_file(core:priv()++"/sql/safe_initialize.sql"),
    Sql.

safe_initialize(DBHandle) ->
    Sql = safe_initialize_sql(),
    sqlite3:sql_exec_script(DBHandle, Sql).

sql_script(DBHandle, SqlScript) ->
    sql_script(DBHandle, SqlScript, ?DB_OP_MAX_MSEC).
sql_script(_DBHandle, _SqlScript, TimeoutMsec) when TimeoutMsec =< 0 ->
    lager:warning("sql_script DATABASE TIMEOUT~n"),
    {error, "Database timeout"};
sql_script(DBHandle, SqlScript, TimeoutMsec) ->
    lager:debug("sql_script DBHandle=~w SqlScript=~s~n", [DBHandle, SqlScript]),
    Results = sqlite3:sql_exec_script(DBHandle, SqlScript),
    case lists:last(Results) of
        {error, ?SQLITE_BUSY, _Reason} ->
            lager:warning("sql_script SQLITE_BUSY, retrying...~n"),
            timer:sleep(?DB_OP_RETRY_MSEC),
            sql_script(DBHandle, "COMMIT;", TimeoutMsec - ?DB_OP_RETRY_MSEC);
        {error, Code, Reason} ->
            lager:warning("sql_script error Code=~w Reason=~s~n", 
                [Code, Reason]),
            {error, Reason};
        _ ->
            {ok, Rev2} = 
                lager:debug("sql_script Success!"),
                get_rev(DBHandle),
            {ok, Rev2}
    end.

% TODO: Use the timeout handling version of exec
sql_exec(DBHandle, SqlStatement) ->
    lager:debug("sql_exec DBHandle=~w SqlExec=~s~n", [DBHandle, SqlStatement]),
    case sqlite3:sql_exec(DBHandle, SqlStatement) of 
        {error, Code, Reason} ->
            lager:warning("sql_exec error Code=~w Reason=~s~n", [Code, Reason]),
            {error, Reason};
        X ->
            lager:debug("sql_exec Success! ~p", [X]),
            {ok, X}
    end.

get_last_inserted_rowid(DBHandle) ->
    {ok, RowId} = case sqlite3:sql_exec(DBHandle,"SELECT last_insert_rowid();")
    of
        [{columns,[_]},{rows,[{null}]}] -> {ok, 0};
        [{columns,[_]},{rows,[{R}]}] -> {ok, R};
        _ -> {ok, 0}
    end,
    {ok, util_babel:to_integer(RowId)}.

get_changed(DBHandle) ->
    {ok, Changes} = case sqlite3:sql_exec(DBHandle,"SELECT changes();") of
        [{columns,[_]},{rows,[{null}]}] -> {ok, 0};
        [{columns,[_]},{rows,[{R}]}] -> {ok, R};
        _ -> {ok, 0}
    end,
    {ok, util_babel:to_integer(Changes)}.

get_rev(DBHandle) ->
    {ok, Rev} = case sqlite3:sql_exec(DBHandle,
        "SELECT MAX(rev) FROM transaction_log;") 
    of
        [{columns,[_]},{rows,[{null}]}] -> {ok, 0};
        [{columns,[_]},{rows,[{R}]}] -> {ok, R};
        _ -> {ok, 0}
    end,
    {ok, util_babel:to_integer(Rev)}.

% FIXME: this is fugly; use parameterized queries e.g. 
% https://github.com/alexeyr/erlang-sqlite3/blob/master/test/sqlite3_test.erl#L129
format(FormatString, Params) ->
    % safely format a parameterized sql query
    Escaped = [sqlite3_lib:escape(util_babel:to_list(P)) || P <- Params],
    lists:flatten(io_lib:format(FormatString, Escaped)).

tests() ->
    {tests, [
        {create_or_open_db, "not tested"},
        {close_db, "not tested"},
        {safe_initialize_sql, "not tested"},
        {safe_initialize, "not tested"},
        {sql_script, "not tested"},
        {sql_exec, "not tested"},
        {get_last_inserted_rowid, "not tested"},
        {get_changed, "not tested"},
        {get_rev, "not tested"},
        {format, "not tested"}
    ]}.


