-module(core_support).
-export([tests/0, parse_client_input/1, client_state/1, client_rev_check/2, 
         dump_fields/2, main_global_fields/0, main_local_fields/0, 
         add_field_if_needed/3, throw_if_not_exists/3, 
         http_code_from_resp_code/1, key_vals/2, get_winamp_id/1, 
         parse_client_id/1, parse_client_rev/1, parse_json/1]).

key_vals(Props, Keys) ->
    % extract Props {key,val} with keys in Keys
    {PropsInKeys,NotInKeys} = util_lists:proplist_part(Props, Keys),
    dump_fields("key_vals in keys:", PropsInKeys),
    dump_fields("key_vals not in keys:", NotInKeys),
    lists:unzip(PropsInKeys).

%% {{{ response codes
%%        200; = OK
%%
%%        400; % Bad Request: General error.
%%             % Input was missing, empty, corrupted, etc.
%%
%%        403; % Forbidden: Client pushed but is out-of-date.
%%             % Client must pull, merge and try again.
%%
%%        409  % Conflict: Client says it's up-to-date but its
%%             % transaction was not compatible with server state.
%%             % This probably indicates an incomplete client
%%             % implementation which isn't properly merging its
%%             % own changes with updates.
%% }}}
http_code_from_resp_code(RespCode) ->
    case RespCode of
        ok        -> 200;
        error     -> 400; % Bad Request: General error.
        forbidden -> 403; % Forbidden: Client pushed but is out-of-date.
        conflict  -> 409  % Conflict: Client lied and did conflicting work
    end.

throw_if_not_exists(F, Fields, Error) ->
    case proplists:is_defined(F, Fields) of
        false -> throw(Error);
        _ -> proplists:get_value(F, Fields)
    end.

add_field_if_needed(Field, ClientId, L) ->
    case proplists:is_defined(Field, L) of
        true -> L;
        _ -> [{Field,ClientId}|L]
    end.

main_global_fields() ->
    [
        <<"GracenoteExtData">>, <<"GracenoteFileID">>, <<"album">>,
        <<"albumartist">>, <<"artist">>, <<"bitrate">>, <<"category">>,
        <<"codec">>, <<"comment">>, <<"composer">>, <<"director">>,
        <<"disc">>, <<"discs">>, <<"filename">>, <<"filesize">>, <<"genre">>, 
        <<"height">>, <<"ispodcast">>, <<"length">>, <<"lossless">>, 
        <<"mediahash">>, <<"mimetype">>, <<"podcastchannel">>, 
        <<"podcastpubdate">>, <<"producer">>, <<"publisher">>, <<"rating">>,
        <<"replaygain_album_gain">>, <<"replaygain_track_gain">>,
        <<"title">>, <<"trackno">>, <<"tracks">>, <<"tuid2">>,
        <<"type">>, <<"width">>, <<"year">>
    ].

main_local_fields() ->
    [
        <<"global_id">>, <<"clientid">>, <<"filetime">>, <<"lastupd">>,
        <<"lastplay">>, <<"playcount">>
    ].

dump_fields(Label, Fields) ->
    FieldsStr = [lists:flatten(io_lib:format("{~s,~s}", 
        [K,util_babel:to_list(V)])) || {K,V} <- Fields],
    lager:debug("~s Fields=~s~n", [Label, string:join(FieldsStr, ",")]).

client_state(_State) ->
    {ok, {"testuser"}}.  % fetch stateful user connection info

client_rev_check(ClientRev, DBHandle) ->
    {ok, Rev} = core_sqlite:get_rev(DBHandle),
    if
        ClientRev < Rev -> {error, too_old, Rev};
        ClientRev > Rev -> {error, too_high, Rev};
        true -> {ok, Rev}
    end.

parse_client_id(undefined) -> {error, "missing HTTP header: X-Winamp-ID"};
parse_client_id(BinId) ->
    StrId = util_babel:to_list(BinId),
    case string:str(StrId, " ") of
        0 -> {ok, StrId};
        _ -> {error, [<<"invalid client id">>]}
    end.

% parse client-supplied revision and ensure it is
% a valid integer [0, 10^15]
parse_client_rev(undefined) -> {error, [<<"undefined POST key: rev">>]};
parse_client_rev(<<"">>) -> {error, [<<"empty POST value: rev">>]};
parse_client_rev(BinRev) ->
    StrRev = util_babel:to_list(BinRev),
    case length(StrRev) > 15 of
        true -> {error, "rev too long"}; % FIXME: 1 quadrillion revisions
        _ ->
            case string:to_integer(StrRev) of
                {error, _Msg} ->
                    {error,
                        [<<"rev not an integer">>]};
                {ClientRev, []} ->
                    case ClientRev < 0 of
                        true ->
                            {error, "rev < 0"};
                        _ ->
                            {ok, ClientRev}
                    end;
                {_, _Leftover} ->
                    {error, [<<"rev not an integer">>]}
            end
    end.

parse_json(undefined) -> {error, [<<"nop">>]};
parse_json(<<"">>) -> {error, [<<"nop">>]};
parse_json(BinXLog) ->
    try
        ClientXLog = jiffy:decode(BinXLog),
        lager:debug("parse_json returned: ~p", [ClientXLog]),
        {ok, ClientXLog}
    catch
        {error, {1, truncated_json}} -> {error, [<<"truncated json">>]};
        {error, {_, invalid_json}} -> {error, [<<"invalid json">>]}
    end.

get_winamp_id(Req) ->
    {RawClientId, _Req} = cowboy_http_req:header(<<"X-Winamp-Id">>, Req),
    {winamp_id, RawClientId}.

tests() ->
    {tests, [
        {key_vals, "not tested"},
        {http_code_from_resp_code, "not tested"},
        {throw_if_not_exists, "not tested"},
        {add_field_if_needed, "not tested"},
        {main_global_fields, ok},
        {main_local_fields, ok},
        {dump_fields, "not tested"},
        {client_state, "not tested"},
        {client_rev_check, "not tested"},
        {parse_client_id, "not tested"},
        {parse_client_rev, "not tested"},
        {parse_json, "not tested"},
        {parse_client_input, "not tested"}
    ]}.
